---
layout: post
title: xv6系列：Lab4核心流程分析
date: 2025-07-21
categories: blog
tags: [OS]
description: 初步全面认知操作系统
---

xv6读书笔记
> 笔记范围：Chapter-6，Section 8.1 ~ 8.3

### 锁和中断
进程的代码本身和中断处理程序可能会持有同样的锁
**核心区别：线程上下文 vs. 中断上下文**
为了彻底搞清楚这个问题，我们必须区分这两种上下文：
#### 1. 线程上下文 (Thread Context)
- **这是什么？** 这是内核代码代表一个特定进程（在 xv6 中即一个内核线程）正常执行时的状态。比如，当一个进程通过系统调用进入内核后，内核为其执行服码就运行在线程上下文中。
    
- **特点：**
    
    - **可调度 (Schedulable):** 它可以被调度器暂停和恢复。
        
    - **可睡眠 (Can Sleep):** 它可以因为等待某个资源（如磁盘 I/O）而调用 `sleep()` 主动放弃 CPU。当它调用 `sleep()` 时，调度器会选择另一个线程来运行。
        
    - **可被中断:** 它的执行可以被硬件中断随时打断。
        

#### 2. 中断上下文 (Interrupt Context)

- **这是什么？** 当一个硬件（如定时器、磁盘、键盘）发来中断信号时，CPU 会强制暂停当前正在执行的任何代码，转而去执行预先注册好的中断处理程序。这个执行环境就是中断上下文。
    
- **特点：**
    
    - **异步执行 (Asynchronous):** 它的发生时间是不可预测的，完全由外部硬件决定。
        
    - **不可调度 (Not Schedulable):** 它不能被调度。它只是“借用”了当前被中断线程的内核栈（虽然有些系统会切换到专门的中断栈），但它本身不是一个线程。
        
    - **不可睡眠 (Cannot Sleep):** 进入会关闭操作系统对设备中断的响应，因此中断上下文将无法退出，进入中断上下文后，中断上下文将一直占据`cpu`直到中断处理程序结束，打开对设备中断的响应

### 为什么这个区别对锁（Lock）至关重要？

现在我们来看，如果一个锁保护的数据被这两种上下文同时使用，会发生什么可怕的事情。这正是 xv6 book 那句话要警示的**死锁风险**。

请看以下致命场景：

1. 一个内核线程 T1 在**线程上下文**中运行，它成功获取了自旋锁 `lk`，正准备操作被保护的数据。
    
    ```C
    // 运行在线程 T1 的上下文中
    acquire(&lk); // 成功获取锁
    // ... 准备操作数据 ...
    ```
    
2. 就在此时，T1 还没有释放锁 `lk`，一个硬件中断（比如定时器中断）在同一个 CPU 核上发生了。
    
3. CPU 硬件强制暂停线程 T1，转而去执行对应的**中断处理程序**。代码现在进入了**中断上下文**。
    
4. 不幸的是，这个中断处理程序也需要访问被 `lk` 保护的同一份数据，于是它也尝试去获取锁 `lk`。
    
    ```C
    // 运行在中断上下文中
    acquire(&lk); // 尝试获取锁
    ```
    
5. **死锁发生！**
    
    - 中断处理程序发现锁 `lk` 已经被线程 T1 持有，所以它开始“自旋”（在一个循环里空转），等待 T1 释放锁。
        
    - 但是，线程 T1 已经被中断处理程序暂停了，它**永远不可能**有机会运行并释放锁 `lk`。
        
    - 结果：中断处理程序永远在等待一个永远不会被释放的锁，而被它中断的线程 T1 永远也得不到恢复。**整个 CPU 核就此被锁死。**

### xv6 的解决方案

为了防止这种致命的死锁，xv6 规定了一种特殊的 `acquire` 锁的方式。当一个锁可能被中断处理程序使用时，在获取这个锁之前，**必须先在当前 CPU 核上禁用中断**。

xv6 的 `acquire()` 函数内部通过调用 `pushcli()` 来实现禁用中断。

```C
// acquire in spinlock.c
void
acquire(struct spinlock *lk)
{
  pushcli(); // 关键！在尝试获取锁之前，先禁用中断
  if(holding(lk))
    panic("acquire");

  while(xchg(&lk->locked, 1) != 0)
    ;
  
  // ...
}
```

这样一来，上面的死锁场景就不会发生： 因为线程 T1 在持有锁 `lk` 的期间，中断是禁用的，所以中断处理程序根本没有机会运行来尝试获取同一个锁。当中断被重新启用时（在 `release()` 函数中），锁 `lk` 肯定已经被释放了。