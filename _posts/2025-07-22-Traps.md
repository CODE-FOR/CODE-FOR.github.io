---
layout: post
title: xv6系列：Lab4核心流程分析
date: 2025-07-22
categories: blog
tags: [OS]
description: 初步全面认知操作系统
---

## xv6读书笔记
### Traps的种类
1. 系统调用，用户程序执行`ecall`指令
2. 一场
3. 设备中断
### RISV-V Trap的机制
**trpas相关的寄存器**
- `stvec`：RISC-V用于处理trap代码的地址
- `spec`：trap发生时，RISV-V将当前的`pc`记录在这里
	> 之后`pc`会被改写为`stvec`中记录的地址，`sret`会将`spec`拷贝到`pc`中，完成返回
- `scause`：记录trap的原因
- `sscratch`
- `sstatus`
	- `SIE bit`：控制设备中断的开关，如果清除了`SIE bit`，设备中断会被屏蔽
	- `SPP bit`：表明trap来自于用户态还是内核态

**traps的过程**
1. 如果trap是设备中断，且`SIE bit`被清除了，那么不执行后续步骤
2. 清除`SIE bit`
3. 将`pc`拷贝到`spec`
4. 将现在的态写入`SPP bit`
5. 记录`scause`
6. 切换到内核态
7. 将`stvec`拷贝到`pc`
8. 开始执行新`pc`
> 在上述过程中CPU没有**切换到内核态页表**，也没有切换到`Kernel Stack`，而且也没有记录除`pc`外的其它寄存器，因此内核必须完成这些工作。

**用户态的trap**
上述trap的过程中**并没有切换页表的操作**，因此`uservec`（`stvec`寄存器中记录的地址）必须在用户态页表中存在映射。
在`uservec`中要完成页表的切换，而为了在页表切换后依然可以在内核态继续执行，这要求`uservec`必须在用户态和内核态页表存在相同的映射。
> xv6通过`trampoline page`完成上述内容，`trampoline page`中包含`uservec`，映射到`TRAMPOLINE`上

当`uservec`开始执行时，所有的寄存器都是有值的，为了`uservec`可以正常执行，`uservec`最开始执行的`csrrw`指令可以交换`a0`和`sscratch`寄存器，让`uservec`可以使用`a0`寄存器完成后续操作。将寄存器保存到`TRAPFRAME`...

**内核态的trap**
内核态的trap的一大特点是页表（`satp`）寄存器已经是`kernel_pagetable`了，所以相关操作会简单很多。内核态的trap会将寄存器保存到对应进程的`Kernel Stack`中。


