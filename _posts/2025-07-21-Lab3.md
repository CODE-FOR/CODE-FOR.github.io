`Lab3`的核心是了解虚拟内存和页表。Lab3实验的难度较高，对`debug`也提出了很高的要求。
- 页表的核心作用是**提供一个从虚拟地址到物理地址的“翻译规则”**。
- 程序运行时，它访问的都是虚拟地址，并认为这是一片连续的内存。但实际上，当指令访问某个虚拟地址时，**CPU硬件会自动根据页表这本“字典”，将虚拟地址翻译成物理地址**，然后再去访问真正的物理内存来读写数据。
- 为了能启动这个翻译过程，CPU必须得先找到这本“字典”。因此，**指向页表起始位置的地址必须是物理地址**，否则CPU会陷入“为了找地图得先查地图”的死循环。
## xv6读书笔记
> 笔记范围：Chapter-3

**xv6操作系统的分页地址组成**
- 虚拟地址采用`Sv39`，使用39bits表示虚拟地址（高27位为页地址，低12位为页内偏移）
- 物理地址有56bits，其中高44位来自于`PTEs(page table entries)`，低12位为页内偏移，从虚拟地址获取拼接
	![[img/Pasted image 20250715104853.png]]
- xv6使用了三级页表模式

**多级页表**
- 根页表为一个4096 byte的页，包含$\frac{4096 byte}{64 bit}=512$个`PTES`，`PTE`中包含下一级页表页的物理地址
- 用虚拟地址（27bits）的高9bits（$2^9=512$，对应512个`PTEs`）在一级页表中定位，中9bits在二级页表中定位，低9bits在三级页表中定位
- 一级页表（根页表）的**物理地址**写入在`stap`寄存器中，每个CPU都有独立的`stap`寄存器
![[img/Pasted image 20250715105708.png]]

**内核地址空间**
![[img/Pasted image 20250721101631.png]]
xv6的内核地址空间如图所示
其中最重要的是**Direct Mapping**的部分，这部分极大的便利了页表的操作，也极大的方便了内核态的诸多操作。
> 操作系统启动的核心环节之一，是从**物理寻址模式**到**虚拟寻址模式（开启分页）** 的切换。
> 切换前，内核已被加载到物理内存（例如，从地址`0x80100000`开始），CPU的程序计数器（PC）正指向一个物理地址并执行代码。
> 当内核执行指令来开启MMU（内存管理单元）时，CPU会**立即开始将PC的值解释为虚拟地址**。假设开启分页的指令位于物理地址`P`，那么下一条指令的地址`P+4`将被CPU作为**虚拟地址**来寻址。
> 为了避免系统崩溃，此时生效的页表**必须**包含一个**恒等映射**或**直接映射（Identity/Direct Mapping）**。该映射要确保内核代码所占的整片虚拟地址空间，都准确地映射到其已加载的物理地址空间。没有这个映射，CPU将无法找到下一条正确的指令，导致系统瞬间失效。

> 不止如此操作系统内核需要直接与内存管理的底层细节交互，例如通过 `walk` 等函数在软件层面遍历页表。这要求内核的内存模型必须能解决一个核心矛盾：
> - **内核执行环境**: 内核是C语言程序，其指令、指针（如`char* p`）都工作在**虚拟地址空间**。
> - **内核管理对象**: 页表数据结构中存储的是**物理页号（PPN）**，最终内存操作的目标也是**物理地址**。
为了让使用虚拟地址的内核代码能无缝操作物理地址和页表，xv6和Linux等宏内核都采用了**直接映射（Direct Mapping）**的设计。
这种设计确保了很大一部分（乃至全部）物理内存，都有一个 `虚拟地址 = 物理地址` 的映射关系。其效果是：
>1. **简化页表遍历**：当内核从一个页表项（PTE）中读出下一级页表的物理地址 `P` 时，它可以直接将 `P` 强制转换为一个指针 `(pagetable_t*)P` 来访问，因为虚拟地址 `P` 就映射在物理地址 `P` 上。
>2. **简化物理内存访问**：当内核通过 `walk` 函数最终计算出某个用户数据对应的物理地址 `pa` 后，它可以直接通过指针 `(char*)pa` 对该物理地址进行读写。


## 实验相关

原本的xv6有一个单独的`kernel_pagetale`，所有进程在切换到内核态时均会从用户态页表切换到该`kernel_pagetable`中。实现了用户态页表和内核态页表的完全隔离。
实验的核心是在内核态破除这种隔离性。**为每个用户进程都建立一个私有的内核态页表，并在内核态页表地址建立用户态虚拟地址到用户态物理地址的映射**

> Linux uses a technique similar to what you have implemented. Until a few years ago many kernels used the same per-process page table in both user and kernel space, with mappings for both user and kernel addresses, to avoid having to switch page tables when switching between user and kernel space. However, that setup allowed side-channel attacks such as Meltdown and Spectre.
> 如果统一内核态页表和用户态页表，也就是用户态页表中也同时包含内核态，虽然会避免陷入内核态时页表切换的开销，但是引入了Meltdown（参考[Meltdown和Spectre](2025-07-21-Meltdown&Spectre.md)）的风险。


